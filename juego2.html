<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>¡Sal en la foto! Desafío Naranja</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Comic+Neue:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #ffde00; 
            background-image: radial-gradient(#facc15 15%, transparent 16%), radial-gradient(#facc15 15%, transparent 16%);
            background-size: 30px 30px;
            background-position: 0 0, 15px 15px;
            font-family: 'Comic Neue', cursive;
            cursor: none;
            user-select: none;
            touch-action: none; 
        }

        #stage {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #viewfinder {
            position: fixed;
            --vf-width: 440px;
            --vf-height: 320px;
            width: var(--vf-width);
            height: var(--vf-height);
            border: 6px solid #000;
            box-shadow: 0 0 0 5000px rgba(0, 0, 0, 0.6), 10px 10px 0px rgba(0,0,0,0.2);
            border-radius: 12px;
            pointer-events: none;
            z-index: 100;
            top: 60%; 
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.05);
            transition: border-color 0.2s, transform 0.1s ease-out;
        }

        @media (max-width: 640px) {
            #viewfinder {
                --vf-width: 280px;
                --vf-height: 200px;
                border-width: 4px;
                top: 50%; 
            }
            .person {
                transform-origin: bottom center;
                scale: 0.6; /* Un poco más pequeño para dar aire */
            }
            #comic-feedback {
                font-size: 50px !important;
                padding: 10px 30px !important;
            }
            .instructions {
                font-size: 18px !important;
                width: 80%;
                text-align: center;
            }
        }

        #viewfinder.perfect {
            border-color: #fbbf24;
            border-width: 8px;
        }

        #flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 1000;
        }

        .corner {
            position: absolute;
            width: 30px;
            height: 30px;
            border: 5px solid #000;
        }
        .top-left { top: -5px; left: -5px; border-right: 0; border-bottom: 0; }
        .top-right { top: -5px; right: -5px; border-left: 0; border-bottom: 0; }
        .bottom-left { bottom: -5px; left: -5px; border-right: 0; border-top: 0; }
        .bottom-right { bottom: -5px; right: -5px; border-left: 0; border-top: 0; }

        .person {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 140px;
            will-change: transform;
            filter: drop-shadow(5px 5px 0px rgba(0,0,0,0.3));
        }

        .speech-bubble {
            position: absolute;
            top: -40px;
            background: white;
            border: 3px solid black;
            border-radius: 20px;
            padding: 5px 12px;
            font-family: 'Bangers', cursive;
            font-size: 18px;
            white-space: nowrap;
            opacity: 0;
            transform: scale(0);
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 10;
        }

        .speech-bubble.active {
            opacity: 1;
            transform: scale(1) translateY(-10px);
        }

        #comic-feedback {
            position: fixed;
            top: 25%; 
            left: 50%;
            transform: translate(-50%, -50%) scale(0) rotate(-10deg);
            font-family: 'Bangers', cursive;
            font-size: 80px;
            color: #fff;
            text-shadow: 8px 8px 0px #000;
            z-index: 500;
            pointer-events: none;
            background: #ef4444;
            padding: 20px 60px;
            border: 8px solid #000;
            transition: transform 0.3s cubic-bezier(0.6, -0.28, 0.735, 0.045);
        }

        .instructions {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #000;
            z-index: 200;
            font-family: 'Bangers', cursive;
            font-size: 24px;
            letter-spacing: 2px;
            background: #fff;
            padding: 10px 30px;
            border: 4px solid #000;
            box-shadow: 6px 6px 0px #000;
            transform: translateX(-50%) rotate(-1deg);
        }

        .rec-indicator {
            position: absolute;
            top: 15px;
            left: 15px;
            background: #ff0000;
            color: white;
            padding: 2px 8px;
            font-family: 'Bangers', cursive;
            border: 2px solid black;
            font-size: 16px;
            animation: blink 0.8s infinite;
        }

        @keyframes blink { 50% { opacity: 0; } }
        
        @keyframes pop {
            0% { transform: translate(-50%, -50%) scale(0) rotate(-10deg); }
            50% { transform: translate(-50%, -50%) scale(1.2) rotate(5deg); }
            100% { transform: translate(-50%, -50%) scale(1) rotate(-2deg); }
        }
    </style>
</head>
<body onclick="takePhoto()" ontouchstart="handleTouch(event)" ontouchmove="handleTouch(event)">

    <div id="flash"></div>
    <div id="comic-feedback">¡PERFECTO!</div>
    <div class="instructions">¡PON AL NARANJA EN EL MEDIO Y HAZ CLIC!</div>
    
    <div id="viewfinder">
        <div class="rec-indicator">CLICK!</div>
        <div class="corner top-left"></div>
        <div class="corner top-right"></div>
        <div class="corner bottom-left"></div>
        <div class="corner bottom-right"></div>
    </div>

    <div id="stage"></div>

    <script>
        const stage = document.getElementById('stage');
        const viewfinder = document.getElementById('viewfinder');
        const flash = document.getElementById('flash');
        const feedback = document.getElementById('comic-feedback');
        const personCount = 7;
        const people = [];
        
        const funPhrases = [
            "¡PATATA!", "¡CHEESE!", "¡MAMMA MIA!", "¡LOOK AT ME!",
            "¡CIAO BELLO!", "¡SAY WHISKY!", "¡SALGO GUAPO?", "¡QUITA BICHO!",
            "¡SMILE!", "¡POLLITO!", "¡PIZZA!", "¡OH MY GOD!",
            "¡AQUÍ!", "¡YEE-HAW!", "¡BELLA!", "¡DO I LOOK GOOD?",
            "¡PHOTO BOMB!", "¡ESPAGUETI!", "¡HOLA CARACOLA!", "¡WHATCHA DOING?",
	    "¡VAMOS!", "¡ESA MANO!", "¡ME MEO!", "¡EEEOO?"
		
        ];

        const characterData = [
            { color: '#ef4444' },
            { color: '#3b82f6' },
            { color: '#10b981' },
            { color: '#f97316', isOrange: true }, 
            { color: '#8b5cf6' },
            { color: '#ec4899' },
            { color: '#06b6d4' }
        ];

        characterData.sort(() => Math.random() - 0.5);

        let mouseX = window.innerWidth / 2;
        let lastMouseMoveTime = Date.now();
        let isMouseIdle = false;
        let feedbackTimer = null;

        function handleTouch(e) {
            if (e.touches && e.touches[0]) {
                updatePosition(e.touches[0].clientX);
            }
        }

        window.addEventListener('mousemove', (e) => {
            updatePosition(e.clientX, e.movementX);
        });

        function updatePosition(x, movementX = 0) {
            mouseX = x;
            viewfinder.style.left = `${mouseX}px`;
            viewfinder.style.transform = `translate(-50%, -50%) rotate(${movementX * 0.2}deg)`;
            lastMouseMoveTime = Date.now();
            if (isMouseIdle) {
                isMouseIdle = false;
                viewfinder.classList.remove('stable');
            }
        }

        function createPerson(index, data) {
            const container = document.createElement('div');
            container.className = 'person';
            
            const startX = (window.innerWidth / (personCount + 1)) * (index + 1);
            
            const personState = {
                id: index,
                el: container,
                currentX: startX,
                currentY: 0,
                velX: 0,
                angle: 0,
                phase: Math.random() * Math.PI * 2,
                personality: 0.02 + Math.random() * 0.1,
                isPosing: false,
                phraseTimer: Math.random() * 200,
                isOrange: data.isOrange || false
            };

            const initialPhrase = personState.isOrange ? "¡ESTOY AQUÍ!" : funPhrases[Math.floor(Math.random() * funPhrases.length)];

            const svg = `
                <div class="speech-bubble" id="bubble-${index}">${initialPhrase}</div>
                <svg width="120" height="200" viewBox="0 0 120 200" style="overflow: visible;">
                    <rect x="42" y="160" width="12" height="40" fill="#000" />
                    <rect x="66" y="160" width="12" height="40" fill="#000" />
                    <path d="M12 170 Q12 60 60 60 Q108 60 108 170" fill="#000" />
                    <path d="M18 165 Q18 70 60 70 Q102 70 102 165" fill="${data.color}" />
                    
                    <circle cx="60" cy="45" r="38" fill="#000" />
                    <circle cx="60" cy="45" r="34" fill="#ffdbac" />
                    
                    <circle cx="45" cy="40" r="10" fill="#000" />
                    <circle cx="45" cy="40" r="8" fill="#fff" />
                    <circle id="p-l-${index}" cx="45" cy="40" r="4" fill="#000" />
                    
                    <circle cx="75" cy="40" r="12" fill="#000" />
                    <circle cx="75" cy="40" r="10" fill="#fff" />
                    <circle id="p-r-${index}" cx="75" cy="40" r="5" fill="#000" />
                    
                    <path id="m-${index}" d="M45 65 Q60 65 75 65" stroke="black" stroke-width="4" stroke-linecap="round" fill="none" />
                </svg>
            `;
            
            container.innerHTML = svg;
            stage.appendChild(container);
            
            personState.pupilL = document.getElementById(`p-l-${index}`);
            personState.pupilR = document.getElementById(`p-r-${index}`);
            personState.mouth = document.getElementById(`m-${index}`);
            personState.bubble = document.getElementById(`bubble-${index}`);
            
            return personState;
        }

        for (let i = 0; i < personCount; i++) {
            people.push(createPerson(i, characterData[i]));
        }

        function takePhoto() {
            flash.style.opacity = '1';
            setTimeout(() => flash.style.opacity = '0', 100);

            const orange = people.find(p => p.isOrange);
            const diff = Math.abs(orange.currentX - mouseX);
            
            const threshold = window.innerWidth < 640 ? 25 : 30;

            if (diff < threshold) {
                showFeedback("¡GENIAL!", "#22c55e");
            } else if (diff < threshold * 5) {
                showFeedback("¡CASI!", "#f59e0b");
            } else {
                showFeedback("¡FALLO!", "#ef4444");
            }
        }

        function showFeedback(text, color) {
            if (feedbackTimer) clearTimeout(feedbackTimer);
            
            feedback.innerText = text;
            feedback.style.background = color;
            feedback.style.animation = 'none';
            feedback.offsetHeight; 
            feedback.style.animation = 'pop 0.6s forwards';
            
            feedbackTimer = setTimeout(() => {
                feedback.style.transform = 'translate(-50%, -50%) scale(0)';
            }, 2000);
        }

        function update() {
            const now = Date.now();
            const isMobile = window.innerWidth < 640;
            
            const vfRect = viewfinder.getBoundingClientRect();
            const vCenterX = mouseX;
            const vCenterY = vfRect.top + vfRect.height / 2;
            
            // AJUSTE CRÍTICO: En móvil elevamos el suelo mucho más (70px vs 20px) 
            // para compensar la escala visual y centrarlo en el visor.
            const floorY = vfRect.bottom - (isMobile ? 70 : 20);

            const detectW = isMobile ? 110 : 190;
            const detectH = isMobile ? 90 : 140;
            const spacing = isMobile ? 48 : 60;

            if (now - lastMouseMoveTime > 800 && !isMouseIdle) {
                isMouseIdle = true;
                viewfinder.classList.add('stable');
            }

            const orange = people.find(p => p.isOrange);
            if (Math.abs(orange.currentX - mouseX) < (isMobile ? 22 : 25)) {
                viewfinder.classList.add('perfect');
            } else {
                viewfinder.classList.remove('perfect');
            }

            people.forEach(p => {
                const headRect = p.el.getBoundingClientRect();
                const hcx = headRect.left + headRect.width / 2;
                // En móvil la cabeza está visualmente más abajo del borde superior del contenedor
                const hcy = headRect.top + (isMobile ? 25 : 45); 
                p.isPosing = Math.abs(hcx - vCenterX) < detectW && Math.abs(hcy - vCenterY) < detectH;
            });

            people.forEach((p, i) => {
                p.phraseTimer--;
                if (p.phraseTimer <= 0) {
                    if (p.phraseTimer === 0 && !p.isOrange) {
                        p.bubble.innerText = funPhrases[Math.floor(Math.random() * funPhrases.length)];
                    }
                    p.bubble.classList.add('active');
                    if (p.phraseTimer < -60) p.phraseTimer = 150 + Math.random() * 250;
                } else {
                    p.bubble.classList.remove('active');
                }

                if (isMouseIdle) {
                    p.velX = 0;
                    p.currentY *= 0.2;
                    p.angle *= 0.2;
                    if (p.isPosing) {
                        p.mouth.setAttribute('d', 'M40 60 Q60 85 80 60'); 
                    }
                } else {
                    if (p.isPosing) {
                        let separationForce = 0;
                        const minDistance = isMobile ? 70 : 100;

                        people.forEach(other => {
                            if (other.id !== p.id && other.isPosing) {
                                const dist = p.currentX - other.currentX;
                                if (Math.abs(dist) < minDistance) {
                                    const force = (minDistance - Math.abs(dist)) * (p.personality * 2);
                                    separationForce += dist > 0 ? force : -force;
                                }
                            }
                        });

                        p.velX *= 0.6; 
                        p.velX += separationForce;
                        p.currentX += p.velX;
                        p.currentY *= 0.7;
                        p.angle *= 0.7;
                        p.mouth.setAttribute('d', 'M45 62 Q60 75 75 62');
                    } else {
                        const offsetFromMouse = (i - (personCount - 1) / 2) * spacing;
                        const targetX = mouseX + offsetFromMouse;
                        const dx = targetX - p.currentX;
                        
                        if (Math.abs(dx) < 0.5) {
                            p.velX = 0;
                            p.currentX = targetX;
                        } else {
                            p.velX = dx * p.personality;
                            p.currentX += p.velX;
                        }

                        const moveSpeed = Math.abs(p.velX);
                        if (moveSpeed > 0.2) {
                            p.currentY = -Math.abs(Math.sin(now * 0.02 + p.phase)) * (moveSpeed * 3);
                            p.angle = Math.sin(now * 0.2 + p.phase) * (moveSpeed * 1.2);
                            p.mouth.setAttribute('d', 'M50 65 Q60 70 70 65');
                        } else {
                            p.currentY *= 0.8;
                            p.angle *= 0.8;
                            p.mouth.setAttribute('d', 'M48 65 Q60 65 72 65');
                        }
                    }
                }

                p.currentX = Math.max(isMobile ? 30 : 60, Math.min(window.innerWidth - (isMobile ? 30 : 60), p.currentX));
                
                // Calculamos la altura visual real
                const visualCharacterHeight = isMobile ? 120 : 200; 
                const topPos = floorY - visualCharacterHeight + p.currentY;
                
                p.el.style.top = `${topPos}px`;
                // Centramos horizontalmente restando la mitad del ancho del SVG escalado
                p.el.style.transform = `translate(${p.currentX - (isMobile ? 42 : 60)}px, 0) rotate(${p.angle}deg)`;
                
                const headRect = p.el.getBoundingClientRect();
                updateEyes(p, vCenterX, vCenterY, headRect.left + headRect.width / 2, headRect.top + (isMobile ? 25 : 45));
            });

            requestAnimationFrame(update);
        }

        function updateEyes(p, vcx, vcy, hcx, hcy) {
            if (isMouseIdle) return; 

            const angle = Math.atan2(vcy - hcy, vcx - hcx);
            const dist = Math.min(8, Math.hypot(vcx - hcx, vcy - hcy) / 40);

            const ox = Math.cos(angle) * dist;
            const oy = Math.sin(angle) * dist;

            p.pupilL.setAttribute('cx', 45 + ox);
            p.pupilL.setAttribute('cy', 40 + oy);
            p.pupilR.setAttribute('cx', 75 + ox);
            p.pupilR.setAttribute('cy', 40 + oy);
        }

        update();
    </script>
</body>
</html>